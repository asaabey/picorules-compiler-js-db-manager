import { compile, Dialect, type RuleblockInput, type CompilationManifest } from 'picorules-compiler-js-core';
import { OracleConnection } from '../db/oracle-connection.js';
import { BatchExecutor, type BatchExecutionResult, type BatchExecutionOptions } from '../execution/index.js';

export interface ValidationResult {
  ruleblockName: string;
  success: boolean;
  compilationTime: number;
  executionTime: number;
  rowCount: number;
  error?: string;
  sql?: string;
  manifest?: CompilationManifest;
}

export class OracleManager {
  constructor(private connection: OracleConnection) {}

  async validateRuleblock(ruleblock: RuleblockInput): Promise<ValidationResult> {
    const startTime = Date.now();

    try {
      // Compile the ruleblock
      const compileStart = Date.now();
      const result = compile([ruleblock], { dialect: Dialect.ORACLE });
      const compilationTime = Date.now() - compileStart;

      if (!result.success) {
        return {
          ruleblockName: ruleblock.name,
          success: false,
          compilationTime,
          executionTime: 0,
          rowCount: 0,
          error: result.errors.map(e => e.message).join('; '),
        };
      }

      const sql = result.sql[0];
      console.log(`\nüìù Compiled ${ruleblock.name} (${compilationTime}ms)`);

      // Clean up any existing table
      const tableName = `ROUT_${ruleblock.name.toUpperCase()}`;
      await this.connection.cleanup(tableName);

      // Execute the SQL
      const execStart = Date.now();
      await this.connection.execute(sql);
      const executionTime = Date.now() - execStart;

      // Query the results to verify
      const queryResult = await this.connection.executeQuery(
        `SELECT COUNT(*) as cnt FROM ${tableName}`
      );
      const rowCount = queryResult.rows?.[0]?.['CNT'] as number || 0;

      console.log(`‚úÖ Executed successfully - ${rowCount} rows (${executionTime}ms)`);

      // Also show sample data
      const sampleResult = await this.connection.executeQuery(
        `SELECT * FROM ${tableName} WHERE ROWNUM <= 5`
      );
      if (sampleResult.rows && sampleResult.rows.length > 0) {
        console.log('üìä Sample data:', JSON.stringify(sampleResult.rows, null, 2));
      }

      return {
        ruleblockName: ruleblock.name,
        success: true,
        compilationTime,
        executionTime,
        rowCount,
        sql,
        manifest: result.manifest,
      };
    } catch (error) {
      return {
        ruleblockName: ruleblock.name,
        success: false,
        compilationTime: Date.now() - startTime,
        executionTime: 0,
        rowCount: 0,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  async validateMultiple(ruleblocks: RuleblockInput[]): Promise<ValidationResult[]> {
    const results: ValidationResult[] = [];

    for (const ruleblock of ruleblocks) {
      const result = await this.validateRuleblock(ruleblock);
      results.push(result);

      if (!result.success) {
        console.error(`\n‚ùå ${ruleblock.name} failed:`, result.error);
      }
    }

    return results;
  }

  /**
   * Validate multiple ruleblocks with dependencies using manifest-based execution
   * This method uses the compilation manifest to ensure correct execution order
   */
  async validateWithDependencies(
    ruleblocks: RuleblockInput[],
    options?: BatchExecutionOptions
  ): Promise<ValidationResult & { batchResult?: BatchExecutionResult }> {
    const startTime = Date.now();

    try {
      // Compile all ruleblocks together (handles dependencies)
      const compileStart = Date.now();
      const result = compile(ruleblocks, { dialect: Dialect.ORACLE });
      const compilationTime = Date.now() - compileStart;

      if (!result.success) {
        return {
          ruleblockName: ruleblocks.map(r => r.name).join(', '),
          success: false,
          compilationTime,
          executionTime: 0,
          rowCount: 0,
          error: result.errors.map(e => e.message).join('; '),
        };
      }

      if (!result.manifest) {
        return {
          ruleblockName: ruleblocks.map(r => r.name).join(', '),
          success: false,
          compilationTime,
          executionTime: 0,
          rowCount: 0,
          error: 'No manifest generated by compiler',
        };
      }

      console.log(`\nüìù Compiled ${ruleblocks.length} ruleblocks (${compilationTime}ms)`);
      console.log(`üìã Manifest: ${result.manifest.totalRuleblocks} ruleblocks in execution order`);

      // Use BatchExecutor for manifest-based execution
      const executor = new BatchExecutor(this.connection, options);
      const batchResult = await executor.execute(result.manifest, result.sql);

      // Calculate total row count from all successful ruleblocks
      const totalRowCount = batchResult.results
        .filter(r => r.success)
        .reduce((sum, r) => sum + r.rowCount, 0);

      // Get the last successful ruleblock's row count for backward compatibility
      const lastSuccessful = batchResult.results.filter(r => r.success).pop();
      const rowCount = lastSuccessful?.rowCount || 0;

      return {
        ruleblockName: ruleblocks.map(r => r.name).join(', '),
        success: batchResult.success,
        compilationTime,
        executionTime: batchResult.totalExecutionTimeMs,
        rowCount,
        sql: result.sql.join('\n\n'),
        manifest: result.manifest,
        batchResult,
      };
    } catch (error) {
      return {
        ruleblockName: ruleblocks.map(r => r.name).join(', '),
        success: false,
        compilationTime: Date.now() - startTime,
        executionTime: 0,
        rowCount: 0,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Execute pre-compiled SQL using a manifest
   * Useful when you already have compilation results and want to re-execute
   */
  async executeFromManifest(
    manifest: CompilationManifest,
    sqlStatements: string[],
    options?: BatchExecutionOptions
  ): Promise<BatchExecutionResult> {
    const executor = new BatchExecutor(this.connection, options);
    return executor.execute(manifest, sqlStatements);
  }
}
